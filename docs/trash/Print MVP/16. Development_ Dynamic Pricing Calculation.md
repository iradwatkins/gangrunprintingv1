**16\. Development: Dynamic Pricing Calculation\*\***

This step implements the dynamic pricing engine. A backend function is created to calculate the final price based on the user's selections, and the frontend is updated to call this function and display the live price.

**\*\*Actions Taken:\*\***

1\. **\*\*Create Backend Pricing Function:\*\*** A **\*\*Supabase Edge Function\*\*** is created to handle the price calculation logic. This function receives the selected product and option IDs, fetches their associated costs from the database, and returns a final calculated price. This aligns with the requirement for a \`POST /api/v1/price-calculator\` endpoint.  
2\. **\*\*Call Function from Frontend:\*\*** The \`ProductDetailPage\` component is updated to call this edge function whenever a user changes an option in the configuration form.  
3\. **\*\*Display Dynamic Price:\*\*** A state variable is added to the component to hold the calculated price, which is then displayed to the user.

Here is the code for the Supabase Edge Function that calculates the price:

\`\`\`typescript  
// File: supabase/functions/price-calculator/index.ts

import { serve } from "\[https://deno.land/std@0.168.0/http/server.ts\](https://deno.land/std@0.168.0/http/server.ts)"  
import { createClient } from '\[https://esm.sh/@supabase/supabase-js@2\](https://esm.sh/@supabase/supabase-js@2)'

serve(async (req) \=\> {  
 try {  
 const { productId, options } \= await req.json();  
 const supabase \= createClient(Deno.env.get('SUPABASE_URL')\!, Deno.env.get('SUPABASE_ANON_KEY')\!);

    // 1\. Fetch base product price
    const { data: product, error: productError } \= await supabase
      .from('products')
      .select('base\_price')
      .eq('id', productId)
      .single();

    if (productError) throw productError;
    let finalPrice \= product.base\_price;

    // 2\. Add costs from selected options (simplified example for paper stock)
    if (options.paperStock) {
        const { data: stock, error: stockError } \= await supabase
            .from('paper\_stocks')
            .select('price\_modifier') // Assuming a 'price\_modifier' column
            .eq('id', options.paperStock)
            .single();

        if (stockError) throw stockError;
        finalPrice \+= stock.price\_modifier;
    }

    // ... logic for other options (coatings, add-ons) would go here ...

    return new Response(JSON.stringify({ finalPrice }), {
      headers: { "Content-Type": "application/json" },
    });

} catch (error) {  
 return new Response(JSON.stringify({ error: error.message }), {  
 status: 400,  
 headers: { "Content-Type": "application/json" },  
 });  
 }  
})  
\`\`\`

Here is the updated \`ProductDetailPage\` component, which now calculates and displays the price:

\`\`\`typescript  
// File: src/pages/ProductDetailPage.tsx  
// (Showing additions and modifications to the previous version)

import { useState, useEffect } from 'react'; // Import useState and useEffect  
import { useParams } from 'react-router-dom';  
import { useQuery } from '@tanstack/react-query';  
import { useForm, Controller } from 'react-hook-form';  
// ... other imports

export function ProductDetailPage() {  
 // ... (existing hooks and queries)  
 const { control, handleSubmit, watch } \= useForm\<ConfigurationFormData\>();  
 const \[calculatedPrice, setCalculatedPrice\] \= useState\<number | null\>(null);

// Watch for changes in the form fields  
 const watchedOptions \= watch();

useEffect(() \=\> {  
 // This function will run whenever the user changes a selection  
 const calculatePrice \= async () \=\> {  
 if (product && watchedOptions.paperStock) {  
 try {  
 const response \= await fetch('/api/v1/price-calculator', { // Assumes function is deployed here  
 method: 'POST',  
 headers: { 'Content-Type': 'application/json' },  
 body: JSON.stringify({  
 productId: product.id,  
 options: watchedOptions  
 })  
 });  
 const data \= await response.json();  
 if (data.finalPrice) {  
 setCalculatedPrice(data.finalPrice);  
 }  
 } catch (error) {  
 console.error("Error calculating price:", error);  
 setCalculatedPrice(null);  
 }  
 }  
 };

    calculatePrice();

}, \[watchedOptions, product\]);

// ... (rest of the component, isLoading checks, etc.)

return (  
 \<div className="p-8 grid md:grid-cols-2 gap-8"\>  
 {/\* ... (left column with image gallery) \*/}

      \<form onSubmit={handleSubmit(onSubmit)} className="space-y-6"\>
        {/\* ... (product header card) \*/}
        {/\* ... (configuration card with form elements) \*/}

        \<Card\>
            \<CardHeader\>
                \<CardTitle\>Your Price\</CardTitle\>
            \</CardHeader\>
            \<CardContent\>
                \<p className="text-4xl font-bold"\>
                    ${(calculatedPrice || product.base\_price).toFixed(2)}
                \</p\>
                \<p className="text-sm text-muted-foreground"\>Price updates based on your selections.\</p\>
            \</CardContent\>
        \</Card\>

        \<Button type="submit" size="lg" className="w-full"\>
          Add to Cart
        \</Button\>
      \</form\>
    \</div\>

);  
}  
\`\`\`
