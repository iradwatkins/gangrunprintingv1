/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
export class PageCollector {
    #browser;
    #initializer;
    storage = new WeakMap();
    constructor(browser, initializer) {
        this.#browser = browser;
        this.#initializer = initializer;
    }
    async init() {
        const pages = await this.#browser.pages();
        for (const page of pages) {
            this.#initializePage(page);
        }
        this.#browser.on('targetcreated', async (target) => {
            const page = await target.page();
            if (!page) {
                return;
            }
            this.#initializePage(page);
        });
    }
    addPage(page) {
        this.#initializePage(page);
    }
    #initializePage(page) {
        if (this.storage.has(page)) {
            return;
        }
        page.on('framenavigated', frame => {
            // Only reset the storage on main frame navigation
            if (frame !== page.mainFrame()) {
                return;
            }
            this.cleanup(page);
        });
        this.#initializer(page, value => {
            const stored = this.storage.get(page) ?? [];
            stored.push(value);
            this.storage.set(page, stored);
        });
    }
    cleanup(page) {
        const collection = this.storage.get(page) ?? [];
        // Keep the reference alive
        collection.length = 0;
    }
    getData(page) {
        return this.storage.get(page) ?? [];
    }
}
export class NetworkCollector extends PageCollector {
    cleanup(page) {
        const requests = this.storage.get(page) ?? [];
        const lastRequestIdx = requests.findLastIndex(request => {
            return request.frame() === page.mainFrame()
                ? request.isNavigationRequest()
                : false;
        });
        // Keep all requests since the last navigation request including that
        // navigation request itself.
        this.storage.set(page, requests.slice(Math.max(lastRequestIdx, 0)));
    }
}
