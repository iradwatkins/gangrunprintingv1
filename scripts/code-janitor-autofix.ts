#!/usr/bin/env node

/**
 * Code Janitor Auto-Fix Script
 * Automatically fixes common code quality issues
 */

import * as fs from 'fs'
import * as path from 'path'

interface FixResult {
  file: string
  changes: string[]
  status: 'success' | 'error'
  error?: string
}

class CodeJanitor {
  private results: FixResult[] = []
  private srcPath: string

  constructor() {
    this.srcPath = path.join(process.cwd(), 'src')
  }

  /**
   * Get all files recursively with specified extensions
   */
  private getAllFiles(dir: string, extensions: string[], fileList: string[] = []): string[] {
    if (!fs.existsSync(dir)) return fileList

    const files = fs.readdirSync(dir)

    for (const file of files) {
      const filePath = path.join(dir, file)
      const stat = fs.statSync(filePath)

      if (stat.isDirectory()) {
        // Skip node_modules and test directories
        if (file === 'node_modules' || file === '.next' || file === 'tests') {
          continue
        }
        this.getAllFiles(filePath, extensions, fileList)
      } else {
        const ext = path.extname(file)
        if (extensions.includes(ext)) {
          // Skip test files
          if (!file.includes('.test.') && !file.includes('.spec.')) {
            fileList.push(filePath.replace(this.srcPath + path.sep, ''))
          }
        }
      }
    }

    return fileList
  }

  /**
   * Main execution method
   */
  async run() {
    console.log('🧹 Starting Code Janitor Auto-Fix...\n')

    // 1. Remove console statements
    await this.removeConsoleLogs()

    // 2. Fix unused imports
    await this.removeUnusedImports()

    // 3. Extract magic numbers
    await this.extractMagicNumbers()

    // 4. Add missing TypeScript types
    await this.addMissingTypes()

    // 5. Fix formatting issues
    await this.fixFormatting()

    // Generate report
    this.generateReport()
  }

  /**
   * Remove console.log statements from production code
   */
  private async removeConsoleLogs() {
    console.log('📝 Removing console statements...')

    const files = this.getAllFiles(this.srcPath, ['.ts', '.tsx', '.js', '.jsx'])

    for (const file of files) {
      const filePath = path.join(this.srcPath, file)
      let content = fs.readFileSync(filePath, 'utf-8')
      const originalContent = content

      // Remove console statements except in development checks
      content = content.replace(
        /console\.(log|error|warn|info|debug)\([^)]*\);?\n?/g,
        (match) => {
          // Keep console.error for error handling
          if (match.includes('console.error') && match.includes('error')) {
            return match
          }
          return ''
        }
      )

      if (content !== originalContent) {
        fs.writeFileSync(filePath, content)
        this.results.push({
          file: filePath,
          changes: ['Removed console statements'],
          status: 'success'
        })
      }
    }
  }

  /**
   * Remove unused imports
   */
  private async removeUnusedImports() {
    console.log('🔍 Removing unused imports...')

    const files = this.getAllFiles(this.srcPath, ['.ts', '.tsx'])

    for (const file of files) {
      const filePath = path.join(this.srcPath, file)
      let content = fs.readFileSync(filePath, 'utf-8')

      // Extract imports and check usage
      const importRegex = /import\s+(?:{[^}]*}|[\w\s,*]+)\s+from\s+['"][^'"]+['"]/g
      const imports = content.match(importRegex) || []

      for (const importLine of imports) {
        const importedItems = this.extractImportedItems(importLine)
        let isUsed = false

        for (const item of importedItems) {
          // Check if the imported item is used in the file (excluding the import line)
          const usageRegex = new RegExp(`\\b${item}\\b`, 'g')
          const contentWithoutImport = content.replace(importLine, '')
          if (usageRegex.test(contentWithoutImport)) {
            isUsed = true
            break
          }
        }

        if (!isUsed && !importLine.includes('React')) {
          content = content.replace(importLine + '\n', '')
          this.results.push({
            file: filePath,
            changes: [`Removed unused import: ${importLine}`],
            status: 'success'
          })
        }
      }

      fs.writeFileSync(filePath, content)
    }
  }

  /**
   * Extract magic numbers to constants
   */
  private async extractMagicNumbers() {
    console.log('🔢 Extracting magic numbers...')

    // Create constants file
    const libPath = path.join(this.srcPath, 'lib')
    if (!fs.existsSync(libPath)) {
      fs.mkdirSync(libPath, { recursive: true })
    }
    const constantsFile = path.join(libPath, 'constants.ts')
    const constants = `/**
 * Application-wide constants
 * Auto-generated by Code Janitor
 */

// File Size Limits
export const MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB
export const MAX_IMAGE_SIZE = 5 * 1024 * 1024 // 5MB
export const MIN_FILE_SIZE = 1024 // 1KB

// Pagination
export const DEFAULT_PAGE_SIZE = 10
export const MAX_PAGE_SIZE = 100
export const DEFAULT_PAGE = 1

// Timeouts
export const DEFAULT_TIMEOUT = 30000 // 30 seconds
export const UPLOAD_TIMEOUT = 120000 // 2 minutes
export const API_TIMEOUT = 10000 // 10 seconds

// Business Logic
export const TAX_RATE = 0.0825 // 8.25%
export const MIN_ORDER_AMOUNT = 10.00
export const MAX_ORDER_AMOUNT = 10000.00
export const DEFAULT_CURRENCY = 'USD'

// UI Constants
export const DEBOUNCE_DELAY = 300 // milliseconds
export const TOAST_DURATION = 5000 // 5 seconds
export const ANIMATION_DURATION = 200 // milliseconds

// Shipping
export const MAX_WEIGHT_LBS = 150
export const MIN_WEIGHT_LBS = 0.1
export const DEFAULT_WAREHOUSE_ZIP = '75001'

// Cache
export const CACHE_TTL = 15 * 60 * 1000 // 15 minutes
export const SESSION_TTL = 24 * 60 * 60 * 1000 // 24 hours
`

    fs.writeFileSync(constantsFile, constants)

    this.results.push({
      file: constantsFile,
      changes: ['Created constants file with extracted magic numbers'],
      status: 'success'
    })

    // Update files to use constants
    const files = this.getAllFiles(this.srcPath, ['.ts', '.tsx']).filter(f => !f.includes('constants.ts'))

    for (const file of files) {
      const filePath = path.join(this.srcPath, file)
      let content = fs.readFileSync(filePath, 'utf-8')
      let changed = false

      // Replace common magic numbers
      const replacements = [
        { pattern: /10 \* 1024 \* 1024/g, replacement: 'MAX_FILE_SIZE', import: true },
        { pattern: /0\.0825/g, replacement: 'TAX_RATE', import: true },
        { pattern: /['"]75001['"]/g, replacement: 'DEFAULT_WAREHOUSE_ZIP', import: true }
      ]

      for (const { pattern, replacement } of replacements) {
        if (pattern.test(content)) {
          content = content.replace(pattern, replacement)
          changed = true
        }
      }

      if (changed) {
        // Add import if not present
        if (!content.includes("from '@/lib/constants'")) {
          content = `import { MAX_FILE_SIZE, TAX_RATE, DEFAULT_WAREHOUSE_ZIP } from '@/lib/constants'\n${content}`
        }

        fs.writeFileSync(filePath, content)
        this.results.push({
          file: filePath,
          changes: ['Replaced magic numbers with constants'],
          status: 'success'
        })
      }
    }
  }

  /**
   * Add missing TypeScript types
   */
  private async addMissingTypes() {
    console.log('📦 Adding missing TypeScript types...')

    const files = this.getAllFiles(this.srcPath, ['.ts', '.tsx'])

    for (const file of files) {
      const filePath = path.join(this.srcPath, file)
      let content = fs.readFileSync(filePath, 'utf-8')
      let changed = false

      // Replace any types with proper types
      content = content.replace(/:\s*any\b/g, (match) => {
        changed = true
        return ': unknown // TODO: Define proper type'
      })

      // Add return types to functions
      content = content.replace(
        /export\s+(async\s+)?function\s+(\w+)\s*\([^)]*\)\s*{/g,
        (match, async, name) => {
          if (!match.includes(':')) {
            changed = true
            const returnType = async ? ': Promise<unknown>' : ': unknown'
            return match.replace('{', `${returnType} {`)
          }
          return match
        }
      )

      if (changed) {
        fs.writeFileSync(filePath, content)
        this.results.push({
          file: filePath,
          changes: ['Replaced any types with unknown', 'Added missing return types'],
          status: 'success'
        })
      }
    }
  }

  /**
   * Fix formatting issues
   */
  private async fixFormatting() {
    console.log('✨ Fixing formatting issues...')

    const files = this.getAllFiles(this.srcPath, ['.ts', '.tsx', '.js', '.jsx'])

    for (const file of files) {
      const filePath = path.join(this.srcPath, file)
      let content = fs.readFileSync(filePath, 'utf-8')

      // Remove trailing whitespace
      content = content.replace(/[ \t]+$/gm, '')

      // Ensure file ends with newline
      if (!content.endsWith('\n')) {
        content += '\n'
      }

      // Remove multiple blank lines
      content = content.replace(/\n\n\n+/g, '\n\n')

      // Fix indentation (convert tabs to 2 spaces)
      content = content.replace(/\t/g, '  ')

      fs.writeFileSync(filePath, content)
    }

    this.results.push({
      file: 'All files',
      changes: ['Fixed formatting issues'],
      status: 'success'
    })
  }

  /**
   * Extract imported items from import statement
   */
  private extractImportedItems(importLine: string): string[] {
    const items: string[] = []

    // Named imports: import { a, b, c } from 'module'
    const namedMatch = importLine.match(/import\s+{([^}]+)}/)
    if (namedMatch) {
      const names = namedMatch[1].split(',').map(s => s.trim().split(' as ')[0])
      items.push(...names)
    }

    // Default import: import Something from 'module'
    const defaultMatch = importLine.match(/import\s+(\w+)\s+from/)
    if (defaultMatch && !importLine.includes('{')) {
      items.push(defaultMatch[1])
    }

    // Namespace import: import * as Something from 'module'
    const namespaceMatch = importLine.match(/import\s+\*\s+as\s+(\w+)/)
    if (namespaceMatch) {
      items.push(namespaceMatch[1])
    }

    return items
  }

  /**
   * Generate final report
   */
  private generateReport() {
    console.log('\n📊 Code Janitor Report\n')
    console.log('=' * 50)

    const successCount = this.results.filter(r => r.status === 'success').length
    const errorCount = this.results.filter(r => r.status === 'error').length

    console.log(`✅ Successful fixes: ${successCount}`)
    console.log(`❌ Errors: ${errorCount}`)
    console.log('\nChanges made:')

    const changesSummary = new Map<string, number>()

    for (const result of this.results) {
      if (result.status === 'success') {
        for (const change of result.changes) {
          const count = changesSummary.get(change) || 0
          changesSummary.set(change, count + 1)
        }
      }
    }

    for (const [change, count] of changesSummary) {
      console.log(`  - ${change}: ${count} files`)
    }

    // Save detailed report
    const reportPath = path.join(process.cwd(), 'code-janitor-results.json')
    fs.writeFileSync(reportPath, JSON.stringify(this.results, null, 2))
    console.log(`\n📁 Detailed report saved to: ${reportPath}`)

    console.log('\n✅ Code Janitor Auto-Fix Complete!')
    console.log('Please review changes and run tests to ensure everything works correctly.')
  }
}

// Run the janitor
const janitor = new CodeJanitor()
janitor.run().catch(console.error)